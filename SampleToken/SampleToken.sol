
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;

// This is class that describes you smart contract.
contract SampleToken {
   

    struct Token{
        string name;
        uint power;
        uint numberOfBullets;

    }
    Token[] tokensArr;
    mapping(uint => uint) tokenToOwner;
    constructor() public {
        // check that contract's public key is set
        require(tvm.pubkey() != 0, 101);
        // Check that message has signature (msg.pubkey() is not zero) and message is signed with the owner's private key
        require(msg.pubkey() == tvm.pubkey(), 102);
        tvm.accept();
    }


    // Modifier that allows function to accept external call only if it was signed
    // with contract owner's public key.
    modifier checkOwnerAndAccept {
        // Check that inbound message was signed with owner's public key.
        // Runtime function that obtains sender's public key.
        require(msg.pubkey() == tvm.pubkey(), 100);

		// Runtime function that allows contract to process inbound messages spending
		// its own resources (it's necessary if contract should process all inbound messages,
		// not only those that carry value with them).
		tvm.accept();
		_;
	}
        function createToken(string name, uint power, uint numberOfBullets) public {
        tvm.accept();
        if (tokensArr.length > 0) {
            for (uint i = 0; i <= tokensArr.length - 1; i++) {
                require(name != tokensArr[i].name, 101);
            }
        }
        tokensArr.push(Token(name, power, numberOfBullets));
        uint KeyAsLastNum = tokensArr.length - 1;
        tokenToOwner[KeyAsLastNum] = msg.pubkey();
    }
    function getTokenOwner(uint tokenId) public view returns(uint) {
        return tokenToOwner[tokenId];

    }
    function getTokenInfo(uint tokenId) public view returns(string tokenName,uint tokenPower,uint tokenNumberOfBullets){
        tokenName=tokensArr[tokenId].name;
        tokenPower=tokensArr[tokenId].power;
        tokenNumberOfBullets=tokensArr[tokenId].numberOfBullets;

    }
    function changeOwner(uint tokenId,uint pubKeyOfNewOwner) public{
        require(msg.pubkey()== tokenToOwner[tokenId],101);
        tvm.accept();
        tokenToOwner[tokenId]=pubKeyOfNewOwner;

    }
    function changePower(uint tokenId,uint power) public{
        require(msg.pubkey()== tokenToOwner[tokenId],101);
        tvm.accept();
        tokensArr[tokenId].power=power;

    }
    function changeNumberOfBullets(uint tokenId,uint numberOfBullets) public{
        require(msg.pubkey()== tokenToOwner[tokenId],101);
        tvm.accept();
        tokensArr[tokenId].numberOfBullets = numberOfBullets;
    }
    
    function  Sale(address dest, uint128 value, bool bounce,uint16 flag) private checkOwnerAndAccept {
         // Runtime function that allows to make a transfer with arbitrary settings.
        dest.transfer(value,bounce,flag);
    }
    // Contract can have a `constructor` â€“ function that will be called when contract will be deployed to the blockchain.
    // In this example constructor adds current time to the instance variable.
    // All contracts need call tvm.accept(); for succeeded deploy
    

  

  
}
